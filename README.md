# Тестовое задание
---
# 1

1. Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?
    - Решал лабораторные работы на PortSwigger
2. Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?
    - Определял поверхность атаки на свое приложение, какие именно интерфейсы (API) доступны пользователю и как он может на них влиять.
3. Если у вас был опыт поиска уязвимостей, расскажите, как это было?
    - В своих веб-приложениях
4. Почему вы хотите участвовать в стажировке?
    - Хочу развиваться в направлении AppSec

# 2 (Security code review)
## Часть 1. Security code review: GO
1. **CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')**
    - В строке ниже при составлении SQL запроса не обрабтывается пользовательский ввод, из за чего злоумышленник может провести SQL инъекцию.
    -   ```golang
        query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
        rows, err := db.Query(query)
        ```
    - В последних версиях MySQL нельзя выполнять системные команды через SQL-запрос. Поэтому атака ограничвается возможностью чтение/удаления/изменения данных в базе данных.
    - Для предотвращения SQL инъекции используются подготовленные запросы. Они защищают на 100%, так как работают на уровне ядра базы данных (MySQL).
        ```golang
        rows, err := db.Query("SELECT * FROM products WHERE name LIKE ?", searchQuery)
        ```
        Так же, часто для предотвращения SQL инъекции используют типизацию и санитизацию пользовательских данных, но это не имеет смысла при использовании подготовленных запросов, лишь порождает дополнительные возможные уязвимости.

## Часть 2. Security code review: Python
### Пример №2.1
1. **CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine**
    - В строке ниже используется шаблонизатор Jinja2. Пользовательский ввод никак не обрабатываеся, что может привести к инъекции шаблона на стороне сервера.  
    - ```output = Template('Hello ' + name + '! Your age is ' + age + '.').render()```
    - В Jinja2 через SSTI можно добится удаленного выполнения кода, если добратся до класса *object*, например передав в *name* инъекцию вида:
        ```python
        {{''.__class__.mro()[1].__subclasses__()[396]('ls -al',shell=True,stdout=-1).communicate()[0].strip()}}
        ```
        Она выведет список файлов и директорий в директории выполнения сервера.
    - Для защиты можно использовать атрибут *safe* в Jinja2, который экранирует специальные управляющие символы, в том числе фигурные скобки, которые нужны для запуска работы шаблонизатора.
2. **CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')**
    - Так же, в это строке есть Отраженная XSS инъекция.
    -   ```python
        output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
        ```
    - Ее эксплуатация может привести к выполнению произвольного JavaScript кода на стороне клиента. С помощью JS можно украсть данные со отрендеренной страницы (HTML) и также незащищенные Cookie (если их защита не настраивалсь атрибутами). Например содержимое переменной *name* вызовет недекларированный скрипт:
        ```js
        <script>alert(1)</script>
        ```
    - Для защиты можно также использовать атрибут *safe* в Jinja2, который экранирует специальные управляющие символы HTML, что не позволит вставить JavaScript вставку.


### Пример №2.2
1. **CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')**
    - В этой строке вызывается системная команда с использованием пользовательского ввода. Пользовательский ввод никак не обрабатывается, из за этого возможно произвольное выполнение кода на сервере.
    -   ```python
        cmd = 'nslookup ' + hostname
        output = subprocess.check_output(cmd, shell=True, text=True)
        ```
    - Один из способов безопасного выполнения системных вызовов, состоит в переключение атрибута **shell=False**. И также передавать в функцию **check_output** массива значений, что запустит первый элемент массива как отдельный процесс, а последующие (пользовательские) как аргументы командой строки.
        ```python
        output = subprocess.check_output(['nslookup', hostname], shell=False, text=True)
        ```
        Но если сама программа nslookup уязвима к произвольным пользовательским данным в аргументах командой строки, то это тоже может привести к уязвимости. Лучше использовать какую-нибудь специализированную библиотку для этого. Например socket.
2. **CWE-918: Server-Side Request Forgery (SSRF)**
    - Так же, есть уязвимость подделки запроса на стороне сервера, так как пользователь контролирует URL запрос, к которому будет обращаться сервер.
        ```python
        cmd = 'nslookup ' + hostname
        output = subprocess.check_output(cmd, shell=True, text=True)
        ```
    - Это может привести к ошибке логики работы програмы, отправляя например запросы на локальные ресурсы сервера (localhost). Защищаться от этой атаки можно посредством белого списка URL адресов или валидацией запроса на наличей там обращения к локальным ресурсам - 127.0.0.1/172.0.0.1/localhost и т.д. 
# 3

Так как все микросервисы приложения лежат в интернете (доступны злоумышленнику), то все они попадают под поверхность атаки.

Пользователь взаимодействует лишь с микрофронтом, поэтому небезопансно оставлять сервисы Backend Layer общедоступными. Необходимо настроить локальную сеть, если микросервисы географически разделены, то посредством VPN. Разрешить доступ к БД, S3, Auth только для Backend App, по IP.

Проверить какие запросы отправляются к БД, используется ли для них пользовательский ввод?
Какой протокол реализиует сервис Auth (Например open-id-connect)?
Используется ли шаблонизатор для отрисовки уведомлений в мессенджеры?
